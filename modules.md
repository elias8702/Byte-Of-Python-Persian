<div dir=rtl>

## ماژول‌ها


حال متوجه شده‌اید که چگونه یک تابع را تعریف کنید و ازان در برنامه‌های دیگر خود استفاده کنید. حال همچنین موضوعی را فرض کنید اگر بخواهید تعدادی از توابع را در برنامه دیگری که می‌نویسید استفاده کنید باید چه کرد؟ فکر می‌کنم همانطور که حدس زده‌اید با استفاده از ماژول‌ها این کار امکان پذیر است.


روش‌های گوناگونی برای نوشتن ماژول‌ها وجود دارد. اما ساده‌ترین روش است که فایلی افزونه‌ی `py.` بسازید که شامل محتویات توابع و متغییرها است.

روش دیگر که برای نوشتن ماژول‌ها می‌توانیم استفاده کنیم این است که ماژول‌ها را با زبان‌برنامه‌نویسی مادری خود که در مترجم پایتون نوشته شده است، بنویسیم. برای مثال ماژول‌ها را به [برنامه‌نویسی سی](http://docs.python.org/3/extending/) می‌نویسید و در زمان کامپایل برنامه، پایتون از مترجم استانداری که در پایتون وجود دارد استفاده می‌کند.


ماژول‌ها را از برنامه‌های دیگر می‌توانید *وارد کنید* (*imported*). تا از توابع و خاصیت‌ها انان استفاده کنید. همچنین از کتابخوانه‌های استاندارد پایتون نیز می‌توانیم استفاده کنیم. حال خواهیم دید که چگونه از ماژول‌های استاندارد کتابخوانه‌ پایتون استفاده کنیم.


برای مثال (فایلی با نام `module_using_sys.py` ذخیره کنید)

<div dir=ltr>


<pre><code class="lang-python">{% include "./programs/module_using_sys.py" %}</code></pre>

<div dir=rtl>

خروجی:
<div dir=ltr>

<pre><code>{% include "./programs/module_using_sys.txt" %}</code></pre>

<div dir=rtl>


**چگونه و چطوری**

در ابتدا ماژول‌های `sys` را *وارد می‌کنیم* این کار با استفاده از دستور `import` انجام می‌شود. اساسا این طوری به پایتون می‌گویم که می‌خواهیم از ماژول استفاده کنیم. ماژول `sys` حاوی توابعی که مربوط به مترجم پایتون و محیط‌اش می‌شود است. بدان معنی که **سیس**تم.

وقتی که پایتون دستور `import sys` را اجرا می‌کند، نگاهی به ماژول `sys` هم کرده است. در این مورد این یک ماژول داخلی است و پایتون می‌داند کجا ان را پیدا کنید.

اگر این یک ماژول کامپایل نشده بود بدان معنی که در پایتون نوشته شده بود، پس پایتون ان را در دارکتوری‌های فهرست شده در متغییر `sys.path` جستجو خواهد کرد. اگر ماژول پیدا شود سپس دستورات بدنه ماژول اجرا خواهد شد و ماژول در *دسترس* قرار خواهد گرفت. نکته، مقدار دهی اولیه یکبار انجام می‌شود وقتی که ماژول را وارد می‌کنیم.

متغییر `argv` در ماژول `sys` با استفاده از نقطه‌ی نمادین `sys.argv` در دسترس است. پس باید این موضوع را درک کرده باشید این اسم قسمتی از ماژول `sys` است. یکی دیگر از مزیت‌های این روش این است که نام `argv` با متغییرهای که در برنامه با این نام دارید باعث مشکل نمی‌شود.

متغییر `sys.argv` *لیستی* (لیست در فصول [بعدی](./data_structures.md#data-structures) توضیح داده خواهد شد) از رشته‌ها است. به طور خاص `sys.argv` لیستی از محتوایات *ارگومان‌های خط‌فرمان* است. این بدان معنی است که دستوراتی را که از ان استفاده می‌کنید شامل می‌شود.

اگر از آی‌دی‌ئی برای اجرا و نوشتن این برنامه‌ها استفاده می‌کنید، دنبال راهی برای مشخص کردن ارگومان‌های خط‌فرمان در منوی برنامه بکنید.

در اینجا وقتی که ماژول‌های پایتون را با استفاده از `sys.py` اجرا می‌کنیم(این‌ها ارگومان هستند)، ماژولی را اجرا کردیم که از ماژول `sys.py` استفاده می‌کند همراه با دستورات `پایتون` و خط فرمان‌های ان به دنبال دارد. پایتون ارگومان‌های خط‌فرمان را در متغییر `sys.argv` ذخیره می‌کند.

به یاد داشته باشید که نام اسکریپت اجرا شده همیشه اولین عنصر لیست `sys.argv` است. بنابراین از `'sys.py به عنوان'` `sys.argv[0]`،  `sys.argv[1]`،  `sys.argv[2]` و ارگومان‌ها هم به عنوان `sys.argv[3]` به کار می‌رود. این نکته را هم در نظر داشته باشید که پایتون شمارش را نه از یک بلکه از صفر شروع می‌کند.

محتویات فایل `sys.path` شمامل لیستی از نام دایرکتوری‌های که ماژول‌ها از انجا وارد(imported) شده‌اند. اگر توجه کنید در خط اول فایل `sys.path` خالی است، این رشته خالی نمایانگر دایرکتوری‌های فعلی است که بخشی از `sys.path` است که همانند متغییر `PYTHONPATH` است. این بدان معنی است که می‌توانید به طور مستقیم وارد ماژول‌های دایرکتوری جاری شوید. در غیر این صورت باید ماژول‌ها خود را در یک از لیست‌های `sys.path` قرار دهید.

این نکته را در نظر داشته باشید منظور از دایرکتوری جاری همان جایی است که از برنامه اجرا می‌شود.  `import os; print(os.getcwd())` اجرا کنید که دایرکتوری جاری برنامه‌ها خود را پیدا کنید.

{#pyc}
## فایل  Byte-compiled .pyc 

ماژول وارکردن یک کار نسبتا گرانبهایی است و پایتون برای این روش ترفندهای برای انجام سریع‌تر این کار دارد. یکی از این روش‌ها ساختن فایل *byte-compiled* با پسوند `.pyc` است که واسطه‌ی است برای پایتون برای تبدیل به ( اگر به یاد داشته باشید  [در بخش مقدمه](./about_python.md#interpreted) در قسمت پایتون چگونه کار می‌کند؟) توضیح داده شد.
این فایل `.pyc` زمانی بدرد می‌خورد که بعدا بخواهیم از یک برنامه دیگر ماژولی را وارد کنیم. این کار باعث می‌شود این امر بسیار سریع‌تر انجام شود زیرا پردازش‌های مربوط به وارد کردن ماژول قبلا انجام شده است. همچین این فایل
بایت‌تغییریافته(Byte-compiled) وابستگی به پلت فرم ندارد.

نـکـتـه: فایل `.pyc` در دایرکتوری جاری که فایل `.py` موجود هست ساخته می‌شود. اگر پایتون اجاز دسترسی برای نوشتن در ان پوشه را نداشته باشد فایل `.pyc` ایـــجـــاد نـــمی شـــود.

{#from-import-statement}

## به واسطه‌ی دستور وارد شده

اگر به طور مستقیم `argv` وارد برنامه‌ی خود کنید(که دیگر هر بار `sys` را وارد نکنید). برای این روش می‌توانید از دستور `from sys import argv` استفاده کنید.

اخــطــار: به طور کلی از دستور `from..import` *اجـتـنـاب* کنید به جای این دستور از دستور `import` استفاده کنید. این موضوع جلوگیری از هرگونه مشکل می‌کند و برنامه خوانا تر می شود.

مثال:

<div dir=ltr>

```python
from math import sqrtе
print("Square root of 16 is", sqrt(16))
```

<div dir=rtl>
